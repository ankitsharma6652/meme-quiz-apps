<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MemeMaster - Trending Viral Memes</title>
    <meta name="description" content="Discover the hottest viral memes and videos from across the internet.">

    <!-- Favicon - Fun Emoji Icon -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üòÇ</text></svg>">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0a0a0c;
            --text-color: #ffffff;
            --primary-gradient: linear-gradient(135deg, #ff00cc, #333399);
            --secondary-gradient: linear-gradient(135deg, #00d2ff, #3a7bd5);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --font-main: 'Outfit', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow-x: hidden;
            min-height: 100vh;
        }

        .background-glow {
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at center, rgba(100, 0, 200, 0.15), transparent 60%);
            z-index: -1;
            animation: pulse 10s infinite alternate;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            100% {
                transform: scale(1.1);
            }
        }

        /* Header & User Menu */
        header {
            text-align: center;
            padding: 3rem 1rem 2rem;
            position: relative;
        }

        .user-menu-container {
            position: absolute;
            top: 1rem;
            right: 2rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            z-index: 100;
        }

        @media (max-width: 768px) {
            .user-menu-container {
                position: relative;
                top: 0;
                right: 0;
                justify-content: center;
                margin-bottom: 1rem;
            }
        }

        .auth-btn {
            padding: 0.5rem 1.2rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
            transition: transform 0.2s;
        }

        .auth-btn:hover {
            transform: translateY(-2px);
        }

        .btn-primary {
            background: var(--secondary-gradient);
            color: white;
            border: none;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-accent {
            background: var(--primary-gradient);
            color: white;
            border: none;
        }

        header h1 {
            font-size: 5rem !important;
            font-weight: 800 !important;
            margin-bottom: 0.5rem;
            letter-spacing: -2px;
            line-height: 1.1;
        }

        header h1 a {
            background: linear-gradient(135deg, #ff00cc, #333399, #00d2ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-decoration: none;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 3rem !important;
            }
        }

        /* Modals */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: #1a1a1f;
            padding: 2rem;
            border-radius: 15px;
            max-width: 400px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            background: #0a0a0c;
            border: 1px solid #333;
            border-radius: 8px;
            color: white;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: #00d2ff;
        }

        /* Meme Feed */
        .meme-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 2rem;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .meme-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .meme-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .meme-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
        }

        .fav-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            transition: transform 0.2s;
            color: #555;
        }

        .fav-btn:hover {
            transform: scale(1.2);
        }

        .fav-btn.active {
            color: #ff0055;
        }

        .meme-media {
            width: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
        }

        .meme-media img,
        .meme-media video {
            max-width: 100%;
            max-height: 700px;
            object-fit: contain;
        }

        .meme-footer {
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            color: #aaa;
            font-size: 0.9rem;
        }

        /* Loading Spinner */
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-top-color: #00d2ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 2rem auto;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Filter Section */
        #filter-section {
            display: none;
            max-width: 700px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Quiz Styles */
        .quiz-option {
            background: #1a1a1f;
            border: 1px solid #333;
            padding: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 1.1rem;
            color: white;
            width: 100%;
            font-family: inherit;
        }

        .quiz-option:hover:not(:disabled) {
            background: #333;
            transform: translateY(-2px);
        }

        .quiz-option.correct {
            background: rgba(40, 167, 69, 0.8) !important;
            border-color: #28a745 !important;
            color: white;
        }

        .quiz-option.wrong {
            background: rgba(220, 53, 69, 0.8) !important;
            border-color: #dc3545 !important;
            color: white;
        }
    </style>
</head>

<body>
    <div id="debug-status"
        style="background:#333; color:#fff; padding:5px; font-size:12px; text-align:center; display:none;">Checking
        login status...</div>
    <div class="background-glow"></div>

    <header>
        <div class="user-menu-container">
            <div id="user-logged-out" style="display:flex; gap:1rem;">
                <a href="/login/google" class="auth-btn btn-primary"
                    style="text-decoration:none; display:flex; align-items:center; gap:0.5rem;">
                    <svg width="18" height="18" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M17.64 9.2c0-.637-.057-1.251-.164-1.84H9v3.481h4.844c-.209 1.125-.843 2.078-1.796 2.717v2.258h2.908c1.702-1.567 2.684-3.874 2.684-6.615z"
                            fill="#4285F4"></path>
                        <path
                            d="M9 18c2.43 0 4.467-.806 5.956-2.18l-2.908-2.259c-.806.54-1.837.86-3.048.86-2.344 0-4.328-1.584-5.036-3.711H.957v2.332A8.997 8.997 0 0 0 9 18z"
                            fill="#34A853"></path>
                        <path
                            d="M3.964 10.71A5.41 5.41 0 0 1 3.682 9c0-.593.102-1.17.282-1.71V4.958H.957A8.996 8.996 0 0 0 0 9c0 1.452.348 2.827.957 4.042l3.007-2.332z"
                            fill="#FBBC05"></path>
                        <path
                            d="M9 3.58c1.321 0 2.508.454 3.44 1.345l2.582-2.58C13.463.891 11.426 0 9 0A8.997 8.997 0 0 0 .957 4.958L3.964 7.29C4.672 5.163 6.656 3.58 9 3.58z"
                            fill="#EA4335"></path>
                    </svg>
                    Sign in with Google
                </a>
            </div>
            <div id="user-logged-in" style="display:none; gap:1rem; align-items:center;">
                <!-- Theme Switcher -->
                <select id="theme-selector" onchange="setTheme(this.value)"
                    style="background:var(--card-bg); color:var(--text-color); border:1px solid var(--border-color); padding:0.5rem; border-radius:8px; cursor:pointer;">
                    <option value="dark">üåô Dark</option>
                    <option value="light">‚òÄÔ∏è Light</option>
                    <option value="cyberpunk">ü§ñ Cyberpunk</option>
                </select>
                <img id="user-avatar" src="" alt="Profile"
                    style="width:32px; height:32px; border-radius:50%; border:2px solid #00d2ff;">
                <span id="username-display" style="color:#00d2ff; font-weight:600;"></span>
                <button id="my-favorites-btn" class="auth-btn btn-accent">‚≠ê Favorites</button>
                <form action="/api/logout-redirect" method="POST" style="display:inline; margin:0;">
                    <button type="submit" class="auth-btn btn-secondary">Logout</button>
                </form>
            </div>
        </div>


        <h1><a href="/" style="color:inherit; text-decoration:none; cursor:pointer;">MemeMaster</a></h1>
        <p style="font-size:1.2rem; color:#aaa; font-weight:300;">Discover the Hottest Viral Memes üî•</p>
    </header>

    <main style="max-width:1400px; margin:0 auto; padding:2rem;">
        <div style="text-align:center; margin-bottom:3rem;">

            <button id="load-btn" onclick="loadMemes()"
                style="background:linear-gradient(135deg, #ff00cc, #333399); color:white; border:none; padding:1rem 3rem; font-size:1.2rem; border-radius:50px; cursor:pointer; font-weight:600; box-shadow:0 10px 30px rgba(255,0,204,0.3); transition:transform 0.3s, box-shadow 0.3s;">
                üöÄ Load Viral Feed
            </button>
            <button id="start-quiz-btn" onclick="startQuiz()"
                style="background:linear-gradient(135deg, #00c6ff, #0072ff); color:white; border:none; padding:1rem 3rem; font-size:1.2rem; border-radius:50px; cursor:pointer; font-weight:600; box-shadow:0 10px 30px rgba(0,198,255,0.3); transition:transform 0.3s; margin-left: 1rem;">
                üß† Take Quiz
            </button>
            <button id="create-btn" onclick="showGenerator()"
                style="background:linear-gradient(135deg, #ff9966, #ff5e62); color:white; border:none; padding:1rem 3rem; font-size:1.2rem; border-radius:50px; cursor:pointer; font-weight:600; box-shadow:0 10px 30px rgba(255,94,98,0.3); transition:transform 0.3s; margin-left: 1rem;">
                üé® Create Meme
            </button>
        </div>

        <div id="filter-section">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:2rem;">
                <div style="display:flex; align-items:center; gap:1rem;">
                    <h1
                        style="font-size:2.5rem; font-weight:800; background: linear-gradient(to right, var(--accent-color), var(--secondary-color)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin:0;">
                        MemeMaster
                    </h1>
                    <span
                        style="background:var(--accent-color); padding:0.2rem 0.6rem; border-radius:12px; font-size:0.8rem; font-weight:bold; color:white;">v2.0</span>
                </div>

                <div style="display:flex; gap:1rem; align-items:center;">

                </div>
            </div>
            <div style="display:flex; gap:1rem; flex-wrap:wrap; align-items:center; justify-content:center;">
                <div style="display:flex; gap:0.5rem; align-items:center;">
                    <label style="color:#aaa; font-size:0.9rem;">Show:</label>
                    <select id="media-filter"
                        style="background:#1a1a1f; color:white; border:1px solid #333; padding:0.5rem 1rem; border-radius:8px; font-family:inherit; cursor:pointer;">
                        <option value="all">All Content</option>
                        <option value="images">Images Only</option>
                        <option value="videos">Videos Only</option>
                    </select>
                </div>

                <div style="display:flex; gap:0.5rem; align-items:center;">
                    <label style="color:#aaa; font-size:0.9rem;">Sort by:</label>
                    <select id="sort-filter"
                        style="background:#1a1a1f; color:white; border:1px solid #333; padding:0.5rem 1rem; border-radius:8px; font-family:inherit; cursor:pointer;">
                        <option value="hot">üî• Hot</option>
                        <option value="top">‚¨ÜÔ∏è Most Upvoted</option>
                        <option value="new">üÜï Newest First</option>
                    </select>
                </div>

                <button id="apply-filters" class="auth-btn btn-primary">Apply Filters</button>
            </div>

            <!-- Info note about video audio -->
            <div
                style="margin-top:1rem; padding:0.75rem 1rem; background:rgba(255,193,7,0.1); border-left:3px solid #ffc107; border-radius:8px; max-width:600px; margin-left:auto; margin-right:auto;">
                <div style="display:flex; align-items:start; gap:0.5rem;">
                    <span style="font-size:1.2rem;">‚ÑπÔ∏è</span>
                    <div style="font-size:0.85rem; color:#ffc107; line-height:1.5;">
                        <strong>Note:</strong> Most videos may not have audio due to platform limitations.
                        For the best experience, try <strong>"Images Only"</strong> filter! üì∏
                    </div>
                </div>
            </div>
        </div>

        <div id="loading" style="display:none; text-align:center;">
            <div class="spinner"></div>
            <p style="font-size:1.2rem; color:#aaa;">Fetching the freshest memes...</p>
        </div>

        <div id="feed-container"></div>

        <div id="quiz-container" style="display:none; max-width:800px; margin:0 auto;">
            <div id="quiz-score-display"
                style="text-align:center; margin-bottom:1rem; font-size:1.5rem; font-weight:bold; color:#00c6ff;">
                Score: <span id="current-score">0</span>
            </div>
            <div id="quiz-card" class="meme-card" style="text-align:center;">
                <!-- Content injected by JS -->
            </div>
        </div>

        <div id="generator-container" style="display:none; max-width:1000px; margin:0 auto;">
            <div style="display:flex; gap:2rem; flex-wrap:wrap;">
                <!-- Template List -->
                <div
                    style="flex:1; min-width:300px; height:600px; overflow-y:auto; background:#1a1a1f; padding:1rem; border-radius:15px; border:1px solid #333;">
                    <h3 style="margin-bottom:1rem; position:sticky; top:0; background:#1a1a1f; padding-bottom:0.5rem;">
                        Choose Template</h3>
                    <div id="template-grid" style="display:grid; grid-template-columns:repeat(2, 1fr); gap:0.5rem;">
                        <!-- Templates injected here -->
                    </div>
                </div>

                <!-- Canvas & Controls -->
                <div style="flex:1.5; min-width:300px;">
                    <div style="background:#1a1a1f; padding:1.5rem; border-radius:15px; border:1px solid #333;">
                        <canvas id="meme-canvas"
                            style="width:100%; max-height:500px; background:#000; border-radius:8px; margin-bottom:1rem;"></canvas>

                        <div style="display:flex; flex-direction:column; gap:1rem;">
                            <div style="display:flex; gap:0.5rem;">
                                <input type="text" id="top-text" placeholder="TOP TEXT" oninput="drawMeme()"
                                    style="flex:1; background:#2a2a2f; border:1px solid #444; color:white; padding:0.8rem; border-radius:8px; font-size:1.1rem;">
                                <input type="range" id="top-text-y" min="0" max="100" value="5" oninput="drawMeme()"
                                    style="width:50px;" title="Move Top Text Vertical">
                            </div>

                            <div style="display:flex; gap:0.5rem;">
                                <input type="text" id="bottom-text" placeholder="BOTTOM TEXT" oninput="drawMeme()"
                                    style="flex:1; background:#2a2a2f; border:1px solid #444; color:white; padding:0.8rem; border-radius:8px; font-size:1.1rem;">
                                <input type="range" id="bottom-text-y" min="0" max="100" value="5" oninput="drawMeme()"
                                    style="width:50px;" title="Move Bottom Text Vertical">
                            </div>

                            <p style="font-size:0.8rem; color:#aaa; text-align:center; margin-top:-0.5rem;">
                                üí° Tip: Click anywhere on the image to add custom text!
                            </p>

                            <!-- Styling Controls -->
                            <div
                                style="display:flex; gap:1rem; align-items:center; background:#2a2a2f; padding:0.5rem; border-radius:8px;">
                                <div style="display:flex; flex-direction:column; align-items:center;">
                                    <label style="font-size:0.7rem; color:#aaa;">Text</label>
                                    <input type="color" id="text-color" value="#ffffff" oninput="drawMeme()"
                                        style="border:none; background:none; cursor:pointer; width:30px; height:30px;">
                                </div>
                                <div style="display:flex; flex-direction:column; align-items:center;">
                                    <label style="font-size:0.7rem; color:#aaa;">Outline</label>
                                    <input type="color" id="outline-color" value="#000000" oninput="drawMeme()"
                                        style="border:none; background:none; cursor:pointer; width:30px; height:30px;">
                                </div>
                                <div style="flex:1; display:flex; flex-direction:column;">
                                    <label style="font-size:0.7rem; color:#aaa;">Font Size</label>
                                    <input type="range" id="font-size" min="20" max="100" value="40"
                                        oninput="drawMeme()" style="width:100%; cursor:pointer;">
                                </div>
                            </div>

                            <!-- Drawing Controls -->
                            <div style="background:#2a2a2f; padding:0.5rem; border-radius:8px; margin-top:0.5rem;">
                                <div
                                    style="display:flex; align-items:center; justify-content:space-between; margin-bottom:0.5rem;">
                                    <label style="font-size:0.9rem; color:#aaa; font-weight:bold;">‚úèÔ∏è Freehand
                                        Draw</label>
                                    <button id="toggle-draw-btn" onclick="toggleDrawMode()"
                                        style="background:#444; color:white; border:none; padding:0.3rem 0.8rem; border-radius:4px; cursor:pointer; font-size:0.8rem;">
                                        Enable Drawing
                                    </button>
                                </div>
                                <div id="draw-controls"
                                    style="display:none; gap:1rem; align-items:center; flex-wrap:wrap;">
                                    <input type="color" id="brush-color" value="#ff0000"
                                        style="border:none; background:none; cursor:pointer; width:30px; height:30px;">
                                    <input type="range" id="brush-size" min="2" max="20" value="5"
                                        style="flex:1; min-width:80px; cursor:pointer;">
                                    <div style="display:flex; gap:0.5rem;">
                                        <button onclick="undoDrawing()"
                                            style="background:#555; color:white; border:none; padding:0.3rem 0.6rem; border-radius:4px; cursor:pointer;">‚Ü©Ô∏è</button>
                                        <button onclick="redoDrawing()"
                                            style="background:#555; color:white; border:none; padding:0.3rem 0.6rem; border-radius:4px; cursor:pointer;">‚Ü™Ô∏è</button>
                                        <button onclick="clearDrawing()"
                                            style="background:#dc3545; color:white; border:none; padding:0.3rem 0.6rem; border-radius:4px; cursor:pointer; font-size:0.8rem;">Clear</button>
                                    </div>
                                </div>
                            </div>

                            <!-- Effects & Stickers -->
                            <div style="margin-top:1rem;">
                                <label
                                    style="font-size:0.9rem; color:#aaa; font-weight:bold; display:block; margin-bottom:0.5rem;">‚ú®
                                    Effects & Stickers</label>
                                <div style="display:flex; gap:0.5rem; align-items:center; flex-wrap:wrap;">
                                    <button id="deep-fry-btn" onclick="toggleDeepFry()"
                                        style="background:linear-gradient(135deg, #ff9900, #ff0000); color:white; border:none; padding:0.5rem 1rem; border-radius:20px; cursor:pointer; font-weight:bold; font-size:0.9rem;">
                                        üî• Deep Fry
                                    </button>

                                    <!-- Emoji Bar -->
                                    <div style="display:flex; gap:0.3rem; overflow-x:auto; padding-bottom:0.2rem;">
                                        <button onclick="addSticker('üòÇ')"
                                            style="background:#333; border:none; font-size:1.5rem; cursor:pointer; border-radius:50%;">üòÇ</button>
                                        <button onclick="addSticker('üíÄ')"
                                            style="background:#333; border:none; font-size:1.5rem; cursor:pointer; border-radius:50%;">üíÄ</button>
                                        <button onclick="addSticker('üî•')"
                                            style="background:#333; border:none; font-size:1.5rem; cursor:pointer; border-radius:50%;">üî•</button>
                                        <button onclick="addSticker('ü§°')"
                                            style="background:#333; border:none; font-size:1.5rem; cursor:pointer; border-radius:50%;">ü§°</button>
                                        <button onclick="addSticker('üß¢')"
                                            style="background:#333; border:none; font-size:1.5rem; cursor:pointer; border-radius:50%;">üß¢</button>
                                        <button onclick="addSticker('üÖ±Ô∏è')"
                                            style="background:#333; border:none; font-size:1.5rem; cursor:pointer; border-radius:50%;">üÖ±Ô∏è</button>
                                        <button onclick="addSticker('üï∂Ô∏è')"
                                            style="background:#333; border:none; font-size:1.5rem; cursor:pointer; border-radius:50%;">üï∂Ô∏è</button>
                                        <button onclick="addSticker('üí©')"
                                            style="background:#333; border:none; font-size:1.5rem; cursor:pointer; border-radius:50%;">üí©</button>
                                    </div>
                                    <!-- Slack Stickers -->
                                    <div style="margin-top:1rem;">
                                        <!-- Slack Stickers (Unicode Version) -->
                                        <div style="margin-top:1rem;">
                                            <label
                                                style="font-size:0.9rem; color:#aaa; font-weight:bold; display:block; margin-bottom:0.5rem;">üöÄ
                                                Slack Stickers</label>
                                            <div
                                                style="display:flex; gap:0.5rem; overflow-x:auto; padding-bottom:0.5rem;">
                                                <button onclick="addSticker('ü¶ú')"
                                                    style="font-size:2rem; background:var(--card-bg); border:1px solid var(--border-color); border-radius:8px; cursor:pointer; padding:0.2rem;"
                                                    title="Parrot">ü¶ú</button>
                                                <button onclick="addSticker('üêï')"
                                                    style="font-size:2rem; background:var(--card-bg); border:1px solid var(--border-color); border-radius:8px; cursor:pointer; padding:0.2rem;"
                                                    title="Doge">üêï</button>
                                                <button onclick="addSticker('üê∏')"
                                                    style="font-size:2rem; background:var(--card-bg); border:1px solid var(--border-color); border-radius:8px; cursor:pointer; padding:0.2rem;"
                                                    title="Pepe">üê∏</button>
                                                <button onclick="addSticker('üòé')"
                                                    style="font-size:2rem; background:var(--card-bg); border:1px solid var(--border-color); border-radius:8px; cursor:pointer; padding:0.2rem;"
                                                    title="Cool">üòé</button>
                                                <button onclick="addSticker('üî•')"
                                                    style="font-size:2rem; background:var(--card-bg); border:1px solid var(--border-color); border-radius:8px; cursor:pointer; padding:0.2rem;"
                                                    title="Fire">üî•</button>
                                                <button onclick="addSticker('ü§°')"
                                                    style="font-size:2rem; background:var(--card-bg); border:1px solid var(--border-color); border-radius:8px; cursor:pointer; padding:0.2rem;"
                                                    title="Clown">ü§°</button>
                                                <button onclick="addSticker('üíé')"
                                                    style="font-size:2rem; background:var(--card-bg); border:1px solid var(--border-color); border-radius:8px; cursor:pointer; padding:0.2rem;"
                                                    title="Diamond Hands">üíé</button>
                                                <button onclick="addSticker('üöÄ')"
                                                    style="font-size:2rem; background:var(--card-bg); border:1px solid var(--border-color); border-radius:8px; cursor:pointer; padding:0.2rem;"
                                                    title="Rocket">üöÄ</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Custom Upload -->
                                <div style="border-top:1px solid #333; padding-top:1rem;">
                                    <label style="display:block; margin-bottom:0.5rem; color:#aaa; font-size:0.9rem;">Or
                                        upload your own image:</label>
                                    <input type="file" id="custom-image-upload" accept="image/*"
                                        onchange="handleImageUpload(this)"
                                        style="color:#aaa; font-size:0.9rem; width:100%;">
                                </div>

                                <!-- AI Generation -->
                                <div style="border-top:1px solid #333; padding-top:1rem; margin-top:1rem;">
                                    <label
                                        style="display:block; margin-bottom:0.5rem; color:#00d2ff; font-size:0.9rem; font-weight:bold;">‚ú®
                                        AI Image Generator (Free Unlimited)</label>
                                    <div style="display:flex; gap:0.5rem;">
                                        <input type="text" id="ai-prompt" placeholder="e.g. Cyberpunk cat eating pizza"
                                            style="flex:1; background:#2a2a2f; border:1px solid #444; color:white; padding:0.8rem; border-radius:8px;">
                                        <button onclick="generateAIImage()"
                                            style="background:linear-gradient(135deg, #00d2ff, #3a7bd5); color:white; border:none; padding:0 1rem; border-radius:8px; cursor:pointer; font-weight:bold;">
                                            Generate
                                        </button>
                                    </div>
                                </div>

                                <div style="display:flex; gap:1rem; margin-top:1rem;">
                                    <button onclick="downloadCreatedMeme()"
                                        style="flex:1; background:linear-gradient(135deg, #ff9966, #ff5e62); color:white; border:none; padding:1rem; font-size:1.1rem; border-radius:8px; cursor:pointer; font-weight:600;">
                                        üíæ Download
                                    </button>
                                    <button onclick="shareCreatedMeme()"
                                        style="flex:1; background:linear-gradient(135deg, #11998e, #38ef7d); color:white; border:none; padding:1rem; font-size:1.1rem; border-radius:8px; cursor:pointer; font-weight:600;">
                                        üì§ Share
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="load-more-btn" style="display:none; text-align:center; margin-top:3rem;">
                <button onclick="loadMemes(true)"
                    style="background:linear-gradient(135deg, #ff00cc, #333399); color:white; border:none; padding:1rem 3rem; font-size:1.1rem; border-radius:50px; cursor:pointer; font-weight:600; box-shadow:0 10px 30px rgba(255,0,204,0.3); transition:transform 0.3s;">
                    üîÑ Load More Memes
                </button>
            </div>

            <div id="close-btn" style="display:none; text-align:center; margin-top:3rem;">
                <button onclick="localStorage.removeItem('mememaster_state'); location.reload();"
                    class="auth-btn btn-secondary">Close Feed</button>
            </div>
    </main>

    <script>
        let allMemes = [];
        let currentUser = null;
        let userFavorites = new Set();
        let currentFilters = {
            mediaType: 'all',
            sortBy: 'hot'
        };


        document.addEventListener('DOMContentLoaded', async () => {
            setupEventListeners();
            await checkAuth();
            restoreAppState(); // Restore previous state on page load
        });

        function setupEventListeners() {
            // Auth Actions
            const favoritesBtn = document.getElementById('my-favorites-btn');

            if (favoritesBtn) {
                favoritesBtn.onclick = () => {
                    if (!currentUser) {
                        alert('Please sign in to view favorites!');
                        return;
                    }
                    loadFavorites();
                };
            }

            // Feed Actions
            document.getElementById('load-btn').onclick = () => {
                document.getElementById('load-btn').style.display = 'none';
                loadMemes();
            };

            document.getElementById('apply-filters').onclick = () => {
                currentFilters.mediaType = document.getElementById('media-filter').value;
                currentFilters.sortBy = document.getElementById('sort-filter').value;
                saveAppState(); // Save filters
                renderMemes();
            };

            // Save scroll position periodically
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    if (allMemes.length > 0) {
                        localStorage.setItem('mememaster_scroll', window.scrollY);
                    }
                }, 500);
            });
        }

        function saveAppState() {
            // Save current state to localStorage
            const state = {
                hasLoadedFeed: allMemes.length > 0,
                filters: currentFilters,
                scrollPosition: window.scrollY,
                viewingFavorites: document.getElementById('close-btn')?.style.display === 'block',
                timestamp: Date.now()
            };
            localStorage.setItem('mememaster_state', JSON.stringify(state));
        }

        function restoreAppState() {
            try {
                const savedState = localStorage.getItem('mememaster_state');
                if (!savedState) {
                    console.log('No saved state found');
                    return;
                }

                const state = JSON.parse(savedState);
                console.log('Restoring state:', state);

                // Only restore if saved within last 2 hours (increased from 30 min)
                const twoHours = 2 * 60 * 60 * 1000;
                if (Date.now() - state.timestamp > twoHours) {
                    console.log('State expired, clearing...');
                    localStorage.removeItem('mememaster_state');
                    return;
                }

                // Restore filters
                if (state.filters) {
                    currentFilters = state.filters;
                    const mediaFilter = document.getElementById('media-filter');
                    const sortFilter = document.getElementById('sort-filter');
                    if (mediaFilter) mediaFilter.value = currentFilters.mediaType;
                    if (sortFilter) sortFilter.value = currentFilters.sortBy;
                    console.log('Filters restored:', currentFilters);
                }

                // Auto-load favorites if user was viewing them
                if (state.viewingFavorites) {
                    console.log('Restoring favorites view...');
                    loadFavorites().then(() => {
                        console.log('Favorites loaded, restoring scroll position...');
                        if (state.scrollPosition && state.scrollPosition > 0) {
                            setTimeout(() => {
                                window.scrollTo({
                                    top: state.scrollPosition,
                                    behavior: 'smooth'
                                });
                                console.log('Scroll restored to:', state.scrollPosition);
                            }, 1000);
                        }
                    });
                }
                // Auto-load feed if it was previously loaded (and not viewing favorites)
                else if (state.hasLoadedFeed) {
                    console.log('Auto-loading previous feed...');
                    const loadBtn = document.getElementById('load-btn');
                    if (loadBtn) loadBtn.style.display = 'none';

                    loadMemes().then(() => {
                        console.log('Feed loaded, restoring scroll position...');
                        // Restore scroll position after content loads
                        if (state.scrollPosition && state.scrollPosition > 0) {
                            setTimeout(() => {
                                window.scrollTo({
                                    top: state.scrollPosition,
                                    behavior: 'smooth'
                                });
                                console.log('Scroll restored to:', state.scrollPosition);
                            }, 1000); // Increased delay for content to fully load
                        }
                    }).catch(err => {
                        console.error('Error loading memes:', err);
                    });
                }
            } catch (e) {
                console.error('Error restoring state:', e);
                // Clear corrupted state
                localStorage.removeItem('mememaster_state');
            }
        }

        async function checkAuth() {
            const status = document.getElementById('debug-status');
            status.style.display = 'block';
            status.innerHTML = "Checking login status...";

            try {
                const res = await fetch('/api/current-user', {
                    credentials: 'include' // Important for cookies
                });
                const data = await res.json();
                console.log("Auth Check Result:", data);

                if (data.authenticated) {
                    currentUser = data.user;
                    updateAuthUI();
                    fetchFavorites();
                    status.style.background = 'green';
                    status.innerHTML = `‚úÖ <b>LOGGED IN:</b> ${currentUser.email}`;
                    setTimeout(() => status.style.display = 'none', 3000);
                } else {
                    status.innerHTML = "Not logged in";
                    status.style.background = '#555';
                    setTimeout(() => status.style.display = 'none', 3000);
                }
            } catch (e) {
                console.error(e);
                status.textContent = "Error: " + e.message;
                status.style.background = 'red';
            }
        }

        function updateAuthUI() {
            console.log("Updating UI for user:", currentUser);
            if (currentUser) {
                document.getElementById('user-logged-out').style.display = 'none';
                const loggedInDiv = document.getElementById('user-logged-in');
                loggedInDiv.style.display = 'flex';

                const nameDisplay = document.getElementById('username-display');
                nameDisplay.textContent = `Hi, ${currentUser.name}`;
                nameDisplay.style.display = 'block'; // Force display

                if (currentUser.picture) {
                    const avatar = document.getElementById('user-avatar');
                    avatar.src = currentUser.picture;
                    avatar.style.display = 'block';
                }
            } else {
                document.getElementById('user-logged-out').style.display = 'flex';
                document.getElementById('user-logged-in').style.display = 'none';
            }
        }

        async function logout() {
            console.log('Logout function called');
            try {
                await fetch('/api/logout', {
                    method: 'POST',
                    credentials: 'include'
                });
                console.log('Logout API call successful');
            } catch (e) {
                console.error('Logout error:', e);
            }
            // Force reload to clear everything
            console.log('Redirecting to homepage...');
            window.location.href = '/';
        }

        // Make logout globally accessible for onclick
        window.logout = logout;

        async function fetchFavorites() {
            if (!currentUser) return;
            try {
                const res = await fetch('/api/favorites', {
                    credentials: 'include'
                });

                if (!res.ok) {
                    console.error('Failed to fetch favorites:', res.status);
                    return;
                }

                const data = await res.json();
                console.log('Favorites response:', data);

                // Check if data is an array
                if (Array.isArray(data)) {
                    userFavorites = new Set(data.map(f => f.meme_id));
                    console.log('Fetched favorites:', userFavorites);
                    // Re-render to update heart icons
                    if (allMemes.length > 0) renderMemes();
                } else {
                    console.error('Favorites data is not an array:', data);
                    userFavorites = new Set();
                }
            } catch (e) {
                console.error('Error fetching favorites:', e);
                userFavorites = new Set();
            }
        }

        async function toggleFavorite(meme, btn) {
            if (!currentUser) {
                alert("Please sign in with Google to save favorites!");
                return;
            }

            const memeId = meme.meme_id || meme.id;
            const isFav = userFavorites.has(memeId);

            if (isFav) {
                // Remove from favorites
                try {
                    const res = await fetch('/api/favorites/by-meme', {
                        method: 'DELETE',
                        credentials: 'include',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            meme_id: memeId
                        })
                    });
                    if (res.ok) {
                        userFavorites.delete(memeId);
                        btn.classList.remove('active');
                        btn.innerHTML = 'ü§ç';
                    }
                } catch (e) { console.error(e); }
            } else {
                // Add to favorites
                try {
                    const res = await fetch('/api/favorites', {
                        method: 'POST',
                        credentials: 'include',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            meme_id: memeId,
                            title: meme.title,
                            url: meme.url || meme.meme_url,
                            is_video: meme.is_video,
                            source: meme.source
                        })
                    });
                    if (res.ok) {
                        userFavorites.add(memeId);
                        btn.classList.add('active');
                        btn.innerHTML = '‚ù§Ô∏è';
                    }
                } catch (e) { console.error(e); }
            }
        }

        async function loadFavorites() {
            if (!currentUser) {
                return;
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('feed-container').innerHTML = '';
            document.getElementById('filter-section').style.display = 'none';

            // Hide other modes
            document.getElementById('quiz-container').style.display = 'none';
            document.getElementById('generator-container').style.display = 'none';

            // Ensure buttons are visible
            document.getElementById('load-btn').style.display = 'inline-block';
            document.getElementById('start-quiz-btn').style.display = 'inline-block';
            document.getElementById('create-btn').style.display = 'inline-block';

            // Show close button to exit
            const closeBtn = document.getElementById('close-btn');
            closeBtn.style.display = 'block';
            closeBtn.querySelector('button').onclick = () => {
                localStorage.removeItem('mememaster_state');
                location.reload();
            };

            try {
                const res = await fetch('/api/favorites', {
                    credentials: 'include'
                });

                if (!res.ok) {
                    throw new Error(`Failed to fetch favorites: ${res.status}`);
                }

                const favorites = await res.json();
                console.log('Loaded favorites:', favorites);

                // Transform favorites to meme format
                // API returns: {id, meme_id, title, url, is_video, source, saved_at}
                allMemes = favorites.map(fav => ({
                    id: fav.meme_id,
                    meme_id: fav.meme_id,
                    title: fav.title || 'Favorite Meme',
                    url: fav.url,
                    meme_url: fav.url,
                    is_video: fav.is_video || false,
                    source: fav.source || 'Favorites',
                    ups: 999,
                    author: 'saved',
                    permalink: fav.url
                }));

                // Log each transformed meme for debugging
                console.log('Transformed memes:');
                allMemes.forEach((meme, i) => {
                    console.log(`${i + 1}. ${meme.title}`);
                    console.log(`   URL: ${meme.url}`);
                    console.log(`   Is Video: ${meme.is_video}`);
                });

                // Update userFavorites set with all loaded favorites
                userFavorites = new Set(allMemes.map(m => m.meme_id));

                document.getElementById('loading').style.display = 'none';
                document.getElementById('close-btn').style.display = 'block';

                // Hide "Load More" button when viewing favorites (all favorites are loaded at once)
                const loadMoreBtn = document.getElementById('load-more-btn');
                if (loadMoreBtn) loadMoreBtn.style.display = 'none';

                if (allMemes.length === 0) {
                    document.getElementById('feed-container').innerHTML = '<p style="text-align:center; padding:3rem; color:#aaa;">You haven\'t saved any favorites yet!<br><br>Click the heart (ü§ç) on any meme to save it.</p>';
                } else {
                    console.log('Rendering', allMemes.length, 'favorites');
                    renderMemes();
                }

                // Save state to persist favorites view on refresh
                saveAppState();

            } catch (e) {
                console.error('Error loading favorites:', e);
                document.getElementById('loading').style.display = 'none';
                document.getElementById('feed-container').innerHTML = '<p style="text-align:center; padding:3rem; color:#ff6b6b;">Failed to load favorites. Please try again.</p>';
            }
        }

        async function downloadMeme(url, title, isVideo) {
            try {
                // Set filename
                const extension = isVideo ? 'mp4' : (url.includes('.gif') ? 'gif' : 'jpg');
                const filename = `${title.substring(0, 50).replace(/[^a-z0-9]/gi, '_')}.${extension}`;

                // Use backend proxy to download
                const proxyUrl = `/api/download-proxy?url=${encodeURIComponent(url)}&filename=${encodeURIComponent(filename)}`;

                // Create download link
                const link = document.createElement('a');
                link.href = proxyUrl;
                link.download = filename;
                link.target = '_blank'; // Fallback for some browsers

                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                console.error('Download failed:', e);
                alert('Download failed. The file might be too large or unavailable.');
            }
        }

        // RSS-based video fetching (Bypasses Reddit API blocks)
        async function fetchRSSVideos() {
            const subs = ['DesiVideoMemes', 'IndianDankMemes', 'bollywoodmemes', 'IndianHumor'];
            const videos = [];

            const fetchPromises = subs.map(async sub => {
                try {
                    // Use rss2json to fetch Reddit RSS feed
                    const rssUrl = encodeURIComponent(`https://www.reddit.com/r/${sub}/hot.rss`);
                    const response = await fetch(`https://api.rss2json.com/v1/api.json?rss_url=${rssUrl}`);
                    if (!response.ok) return;

                    const data = await response.json();
                    if (!data.items) return;

                    data.items.forEach(item => {
                        // Extract v.redd.it link from content HTML
                        const content = item.content || '';
                        const match = content.match(/href="(https:\/\/v\.redd\.it\/[^"]+)"/);

                        if (match) {
                            const vReddItUrl = match[1];
                            // Construct direct MP4 URL (Note: Audio might be missing in simple DASH)
                            // We try to guess the filename. Usually DASH_720.mp4 or DASH_1080.mp4
                            const videoId = vReddItUrl.split('/').pop();
                            const mp4Url = `https://v.redd.it/${videoId}/DASH_720.mp4`;

                            videos.push({
                                id: videoId,
                                title: item.title,
                                url: item.link,
                                meme_url: mp4Url, // Direct MP4
                                is_video: true,
                                source: `r/${sub}`,
                                ups: 100 + Math.floor(Math.random() * 900), // Fake ups since RSS doesn't have them
                                author: item.author,
                                permalink: item.link
                            });
                        }
                    });
                    console.log(`‚úÖ RSS success for ${sub}: Found ${videos.length} videos`);
                } catch (e) {
                    console.warn(`RSS failed for ${sub}:`, e);
                }
            });

            await Promise.all(fetchPromises);

            // Fallback if RSS also fails
            if (videos.length === 0) {
                console.warn("RSS failed. Loading fallback videos.");
                videos.push(
                    {
                        id: 'fallback_1',
                        title: 'When the code finally works',
                        url: 'https://v.redd.it/fallback1',
                        meme_url: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4',
                        is_video: true,
                        source: 'System',
                        ups: 999,
                        author: 'MemeMaster'
                    },
                    {
                        id: 'fallback_2',
                        title: 'Me waiting for deployment',
                        url: 'https://v.redd.it/fallback2',
                        meme_url: 'https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/ElephantsDream.mp4',
                        is_video: true,
                        source: 'System',
                        ups: 888,
                        author: 'MemeMaster'
                    }
                );
            }

            return videos;
        }

        async function loadMemes(append = false) {
            const loading = document.getElementById('loading');
            const feedContainer = document.getElementById('feed-container');
            const filterSection = document.getElementById('filter-section');
            const closeBtn = document.getElementById('close-btn');
            const loadMoreBtnDiv = document.getElementById('load-more-btn');
            const loadMoreBtn = loadMoreBtnDiv ? loadMoreBtnDiv.querySelector('button') : null;

            loading.style.display = 'block';
            if (!append) {
                feedContainer.innerHTML = '';
                filterSection.style.display = 'none';
                closeBtn.style.display = 'none';

                // Hide other modes
                document.getElementById('quiz-container').style.display = 'none';
                document.getElementById('generator-container').style.display = 'none';

                // Ensure buttons are visible
                document.getElementById('load-btn').style.display = 'inline-block';
                document.getElementById('start-quiz-btn').style.display = 'inline-block';
                document.getElementById('create-btn').style.display = 'inline-block';
            }

            if (loadMoreBtn) {
                loadMoreBtn.innerHTML = '<span class="loading-spinner"></span> Loading...';
                loadMoreBtn.disabled = true;
            }

            try {
                // Fetch memes from backend (includes Reddit, Instagram, Twitter, 9GAG)
                const response = await fetch('/api/memes');
                const newMemes = await response.json();

                if (!append) {
                    allMemes = newMemes;
                } else {
                    allMemes = [...allMemes, ...newMemes];
                }

                loading.style.display = 'none';
                filterSection.style.display = 'block';

                if (closeBtn) closeBtn.style.display = 'block';
                if (loadMoreBtnDiv) loadMoreBtnDiv.style.display = 'block';

                // Refresh favorites
                if (currentUser && !append) {
                    await fetchFavorites();
                }

                // Render (pass append flag and new items if appending)
                renderMemes(append, newMemes);

                // Save state after successful load
                saveAppState();

            } catch (error) {
                console.error('Error loading memes:', error);
                loading.innerHTML = `<div style="text-align:center; padding:2rem;"><h3>‚ö†Ô∏è Failed to load memes</h3><p>Please check your connection and try again.</p><button onclick="location.reload()" class="action-btn" style="margin-top:1rem;">Retry</button></div>`;
            } finally {
                if (loadMoreBtn) {
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.innerHTML = 'üîÑ Load More Memes';
                }
            }
        }

        function renderMemes(append = false, newItems = null) {
            const container = document.getElementById('feed-container');

            if (!append) {
                container.innerHTML = '';
            }

            let sourceArray = append && newItems ? newItems : allMemes;

            let filtered = sourceArray.filter(meme => {
                if (currentFilters.mediaType === 'images') return !meme.is_video;
                if (currentFilters.mediaType === 'videos') return meme.is_video;
                return true;
            });

            if (currentFilters.sortBy === 'top') {
                filtered.sort((a, b) => b.ups - a.ups);
            } else if (currentFilters.sortBy === 'new') {
                filtered.sort(() => Math.random() - 0.5);
            }

            if (filtered.length === 0 && !append) {
                container.innerHTML = `
                    <div style="text-align:center; padding:4rem 1rem; color:#666;">
                        <div style="font-size:3rem; margin-bottom:1rem;">üòï</div>
                        <h3>No memes found</h3>
                        <p>Try changing your filters or check back later!</p>
                    </div>
                `;
                return;
            }

            filtered.forEach(meme => {
                const card = document.createElement('div');
                card.className = 'meme-card';

                const isFav = userFavorites.has(meme.meme_id || meme.id);
                const heartIcon = isFav ? '‚ù§Ô∏è' : 'ü§ç';
                const activeClass = isFav ? 'active' : '';

                // Determine if this is a Reddit video (needs sync player) or other source (standard player)
                const isRedditVideo = meme.source === 'Reddit' || meme.id.startsWith('reddit_');
                const uniqueId = `player-${meme.id}`;
                const audioSrc = `https://v.redd.it/${meme.id}/DASH_audio.mp4`;

                const mediaContent = meme.is_video ? (
                    isRedditVideo ? `
                        <div style="position:relative; width:100%; background:#000; border-radius:8px; overflow:hidden;" class="custom-player" id="${uniqueId}">
                            <video
                                id="${uniqueId}-video"
                                playsinline
                                loop
                                poster="${meme.url}"
                                referrerpolicy="no-referrer"
                                style="width:100%; max-height:600px; object-fit:contain; display:block; cursor:pointer;"
                                onclick="togglePlay('${uniqueId}')"
                                onerror="console.error('Video error:', this.error)"
                            >
                                <source src="https://v.redd.it/${meme.id}/DASH_1080.mp4" type="video/mp4">
                                <source src="https://v.redd.it/${meme.id}/DASH_720.mp4" type="video/mp4">
                                <source src="https://v.redd.it/${meme.id}/DASH_480.mp4" type="video/mp4">
                                <source src="https://v.redd.it/${meme.id}/DASH_360.mp4" type="video/mp4">
                                <source src="https://v.redd.it/${meme.id}/DASH_240.mp4" type="video/mp4">
                            </video>

                            <audio id="${uniqueId}-audio" loop style="display:none;" onerror="console.log('Audio missing for ${meme.id}')">
                                <source src="${audioSrc}" type="audio/mp4">
                            </audio>

                            <div id="${uniqueId}-overlay" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); pointer-events:none; transition:opacity 0.3s;">
                                <div style="background:rgba(0,0,0,0.6); border-radius:50%; padding:1.5rem; display:flex; align-items:center; justify-content:center;">
                                    <span style="font-size:2rem;">‚ñ∂Ô∏è</span>
                                </div>
                            </div>

                            <button onclick="toggleMute(event, '${uniqueId}')" style="position:absolute; bottom:15px; right:15px; background:rgba(0,0,0,0.6); border:none; border-radius:50%; width:40px; height:40px; cursor:pointer; color:white; font-size:1.2rem; display:flex; align-items:center; justify-content:center; transition:background 0.2s;">
                                <span id="${uniqueId}-mute-icon">üîá</span>
                            </button>
                        </div>
                    ` : `
                        <video
                            controls
                            playsinline
                            loop
                            preload="metadata"
                            style="width:100%; max-height:600px; object-fit:contain; border-radius:8px; background:#000;"
                            poster="${meme.url}"
                        >
                            <source src="${meme.url || meme.meme_url}" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    `
                ) : `
                    <img src="${meme.url || meme.meme_url}" alt="${meme.title}" loading="lazy" style="border-radius:8px;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22400%22 height=%22300%22%3E%3Crect fill=%22%23333%22 width=%22400%22 height=%22300%22/%3E%3Ctext fill=%22%23999%22 font-size=%2214%22 x=%2250%25%22 y=%2245%25%22 text-anchor=%22middle%22%3Eüì∑%3C/text%3E%3Ctext fill=%22%23999%22 font-size=%2212%22 x=%2250%25%22 y=%2255%25%22 text-anchor=%22middle%22%3EImage expired%3C/text%3E%3Ctext fill=%22%23666%22 font-size=%2210%22 x=%2250%25%22 y=%2265%25%22 text-anchor=%22middle%22%3E(Meme URLs expire after some time)%3C/text%3E%3Csvg%3E'">
                `;

                // Simplified card structure without author info
                card.innerHTML = `
                    <div class="meme-header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                        <div class="meme-title" style="font-size:1.2rem; font-weight:600; flex:1;">${meme.title}</div>
                        <button class="action-btn" onclick="shareMeme('${meme.url}')" style="margin-left:1rem;">‚ÜóÔ∏è</button>
                    </div>

                    ${mediaContent}

                    <div class="meme-footer">
                        <div class="meme-stats">
                            <span>üî• ${meme.ups} ups</span>
                        </div>
                        <div class="meme-actions">
                            <button class="action-btn like-btn ${activeClass}" onclick='toggleFavorite(${JSON.stringify(meme).replace(/'/g, "&#39;")}, this)'>
                                ${heartIcon}
                            </button>
                            <button class="action-btn" onclick="downloadMeme('${meme.url}', '${meme.title.replace(/'/g, "")}', ${meme.is_video})">
                                ‚¨áÔ∏è
                            </button>
                        </div>
                    </div>
                `;

                container.appendChild(card);
            });
        }

        function shareMeme(url) {
            if (navigator.share) {
                navigator.share({
                    title: 'Check out this meme!',
                    url: url
                }).catch(console.error);
            } else {
                navigator.clipboard.writeText(url).then(() => alert('Link copied to clipboard!'));
            }
        }

        async function toggleFavorite(meme, btn) {
            if (!currentUser) {
                alert("Please sign in with Google to save favorites!");
                return;
            }

            const memeId = meme.meme_id || meme.id;
            const isFav = userFavorites.has(memeId);

            if (isFav) {
                // Remove
                try {
                    const res = await fetch('/api/favorites/by-meme', {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ meme_id: memeId })
                    });
                    if (res.ok) {
                        userFavorites.delete(memeId);
                        btn.classList.remove('active');
                        btn.innerHTML = 'ü§ç';
                    }
                } catch (e) { console.error(e); }
            } else {
                // Add
                try {
                    const res = await fetch('/api/favorites', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            meme_id: memeId,
                            title: meme.title,
                            url: meme.url || meme.meme_url,
                            is_video: meme.is_video,
                            source: meme.source
                        })
                    });
                    if (res.ok) {
                        userFavorites.add(memeId);
                        btn.classList.add('active');
                        btn.innerHTML = '‚ù§Ô∏è';
                    }
                } catch (e) { console.error(e); }
            }
        }

        // Custom Player Controls
        function togglePlay(id) {
            const video = document.getElementById(`${id}-video`);
            const audio = document.getElementById(`${id}-audio`);
            const overlay = document.getElementById(`${id}-overlay`);

            if (video.paused) {
                video.play();
                audio.play().catch(e => console.log("Audio play failed (might be missing):", e));
                overlay.style.opacity = '0';
            } else {
                video.pause();
                audio.pause();
                overlay.style.opacity = '1';
            }

            // Sync check
            if (Math.abs(video.currentTime - audio.currentTime) > 0.5) {
                audio.currentTime = video.currentTime;
            }
        }

        function toggleMute(e, id) {
            e.stopPropagation();
            const video = document.getElementById(`${id}-video`);
            const audio = document.getElementById(`${id}-audio`);
            const icon = document.getElementById(`${id}-mute-icon`);

            if (audio.muted || audio.volume === 0) {
                audio.muted = false;
                audio.volume = 1;
                icon.innerHTML = 'üîä';
            } else {
                audio.muted = true;
                icon.innerHTML = 'üîá';
            }
        }
        // Quiz Logic
        let quizScore = 0;
        let isQuizActive = false;

        async function startQuiz() {
            isQuizActive = true;
            quizScore = 0;
            document.getElementById('current-score').innerText = '0';

            // Hide feed elements
            // Hide feed elements
            document.getElementById('feed-container').innerHTML = '';
            document.getElementById('filter-section').style.display = 'none';
            document.getElementById('load-more-btn').style.display = 'none';
            document.getElementById('generator-container').style.display = 'none';

            // Ensure buttons are visible
            document.getElementById('load-btn').style.display = 'inline-block';
            document.getElementById('start-quiz-btn').style.display = 'inline-block';
            document.getElementById('create-btn').style.display = 'inline-block';

            // Show close button to exit
            const closeBtn = document.getElementById('close-btn');
            closeBtn.style.display = 'block';
            closeBtn.querySelector('button').onclick = () => {
                localStorage.removeItem('mememaster_state');
                location.reload();
            };

            // Show quiz elements
            document.getElementById('quiz-container').style.display = 'block';

            // Load first question
            loadQuizQuestion();
        }

        async function loadQuizQuestion() {
            const quizCard = document.getElementById('quiz-card');
            quizCard.innerHTML = '<div class="spinner" style="margin: 3rem auto;"></div><p>Loading question...</p>';

            try {
                const res = await fetch('/api/quiz/question');
                const data = await res.json();

                if (data.error) throw new Error(data.error);

                renderQuizQuestion(data);
            } catch (e) {
                console.error(e);
                quizCard.innerHTML = '<p style="color:red">Failed to load question. <button onclick="loadQuizQuestion()" class="action-btn">Try Again</button></p>';
            }
        }

        function renderQuizQuestion(data) {
            const quizCard = document.getElementById('quiz-card');

            let mediaHtml = '';
            if (data.type === 'video') {
                mediaHtml = `
                    <video controls autoplay loop muted style="width:100%; max-height:500px; border-radius:8px; margin-bottom:1rem;">
                        <source src="${data.meme_url}" type="video/mp4">
                    </video>
                `;
            } else {
                mediaHtml = `<img src="${data.meme_url}" style="width:100%; max-height:500px; object-fit:contain; border-radius:8px; margin-bottom:1rem;">`;
            }

            quizCard.innerHTML = `
                <h3 style="margin-bottom:1rem;">Guess the Category!</h3>
                ${mediaHtml}
                <p style="font-style:italic; color:#aaa; margin-bottom:1.5rem;">"${data.title}"</p>

                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:1rem;">
                    ${data.options.map(opt => `
                        <button class="quiz-option" onclick="checkAnswer(this, '${opt}', '${data.correct_answer}')">
                            ${opt}
                        </button>
                    `).join('')}
                </div>
            `;
        }

        function checkAnswer(btn, selected, correct) {
            const buttons = document.querySelectorAll('.quiz-option');
            buttons.forEach(b => b.disabled = true);

            if (selected === correct) {
                btn.classList.add('correct');
                quizScore++;
                document.getElementById('current-score').innerText = quizScore;

                // Simple confetti effect using colored squares
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
                for (let i = 0; i < 20; i++) {
                    const el = document.createElement('div');
                    el.style.position = 'fixed';
                    el.style.left = (btn.getBoundingClientRect().left + btn.offsetWidth / 2) + 'px';
                    el.style.top = (btn.getBoundingClientRect().top) + 'px';
                    el.style.width = '10px';
                    el.style.height = '10px';
                    el.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    el.style.transition = 'all 1s ease-out';
                    document.body.appendChild(el);

                    setTimeout(() => {
                        el.style.transform = `translate(${Math.random() * 200 - 100}px, ${Math.random() * 200 - 100}px) rotate(${Math.random() * 360}deg)`;
                        el.style.opacity = '0';
                    }, 10);

                    setTimeout(() => el.remove(), 1000);
                }

            } else {
                btn.classList.add('wrong');
                // Highlight correct answer
                buttons.forEach(b => {
                    if (b.innerText.includes(correct)) b.classList.add('correct');
                });
            }

            setTimeout(() => {
                loadQuizQuestion();
            }, 1500);
        }

        // Meme Generator Logic
        let currentTemplate = null;
        let memeCanvas = document.getElementById('meme-canvas');
        let ctx = memeCanvas.getContext('2d');

        async function showGenerator() {
            // Hide other sections
            // Hide other sections
            document.getElementById('feed-container').innerHTML = '';
            document.getElementById('filter-section').style.display = 'none';
            document.getElementById('load-more-btn').style.display = 'none';
            document.getElementById('quiz-container').style.display = 'none';

            // Ensure buttons are visible
            document.getElementById('load-btn').style.display = 'inline-block';
            document.getElementById('start-quiz-btn').style.display = 'inline-block';
            document.getElementById('create-btn').style.display = 'inline-block';

            // Show generator
            document.getElementById('generator-container').style.display = 'block';

            // Show close button
            const closeBtn = document.getElementById('close-btn');
            closeBtn.style.display = 'block';
            closeBtn.querySelector('button').onclick = () => {
                localStorage.removeItem('mememaster_state');
                location.reload();
            };

            // Fetch templates if empty
            if (document.getElementById('template-grid').children.length === 0) {
                await fetchTemplates();
            }
        }

        async function fetchTemplates() {
            try {
                const res = await fetch('https://api.imgflip.com/get_memes');
                const data = await res.json();

                if (data.success) {
                    const grid = document.getElementById('template-grid');
                    data.data.memes.forEach(meme => {
                        const div = document.createElement('div');
                        div.innerHTML = `<img src="${meme.url}" style="width:100%; border-radius:4px; cursor:pointer; border:2px solid transparent;" loading="lazy" alt="${meme.name}">`;
                        div.onclick = () => selectTemplate(meme, div);
                        grid.appendChild(div);
                    });

                    // Select first one by default
                    if (data.data.memes.length > 0) {
                        selectTemplate(data.data.memes[0], grid.children[0]);
                    }
                }
            } catch (e) {
                console.error('Error fetching templates:', e);
            }
        }

        function selectTemplate(meme, element) {
            currentTemplate = meme;

            // Highlight selection
            const grid = document.getElementById('template-grid');
            Array.from(grid.children).forEach(c => c.querySelector('img').style.borderColor = 'transparent');
            element.querySelector('img').style.borderColor = '#ff5e62';

            // Load image to canvas
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                memeCanvas.width = img.width;
                memeCanvas.height = img.height;
                drawMeme();
            };
            img.src = meme.url;
        }

        function handleImageUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.onload = function () {
                        // Set as current template
                        currentTemplate = {
                            url: e.target.result,
                            width: img.width,
                            height: img.height,
                            isCustom: true
                        };

                        // Reset selection in grid
                        const grid = document.getElementById('template-grid');
                        Array.from(grid.children).forEach(c => c.querySelector('img').style.borderColor = 'transparent');

                        // Update canvas dimensions
                        // Limit max width for performance/display
                        const maxWidth = 800;
                        if (img.width > maxWidth) {
                            const scale = maxWidth / img.width;
                            memeCanvas.width = maxWidth;
                            memeCanvas.height = img.height * scale;
                        } else {
                            memeCanvas.width = img.width;
                            memeCanvas.height = img.height;
                        }

                        drawMeme();
                    }
                    img.src = e.target.result;
                }
                reader.readAsDataURL(input.files[0]);
            }
        }

        // Drawing Logic
        let isDrawing = false;
        let isDrawMode = false;
        let drawingLayer = document.createElement('canvas'); // Off-screen canvas for drawing
        let drawCtx = drawingLayer.getContext('2d');
        let lastX = 0;
        let lastY = 0;

        // Undo/Redo History
        let drawHistory = [];
        let historyStep = -1;

        function saveDrawingState() {
            historyStep++;
            if (historyStep < drawHistory.length) {
                drawHistory.length = historyStep; // Truncate redo history
            }
            drawHistory.push(drawingLayer.toDataURL());
        }

        function undoDrawing() {
            if (historyStep > 0) {
                historyStep--;
                restoreDrawingState(drawHistory[historyStep]);
            } else if (historyStep === 0) {
                historyStep = -1;
                clearDrawingLayer();
                drawMeme();
            }
        }

        function redoDrawing() {
            if (historyStep < drawHistory.length - 1) {
                historyStep++;
                restoreDrawingState(drawHistory[historyStep]);
            }
        }

        function restoreDrawingState(dataUrl) {
            const img = new Image();
            img.onload = () => {
                clearDrawingLayer();
                drawCtx.drawImage(img, 0, 0);
                drawMeme();
            };
            img.src = dataUrl;
        }

        function clearDrawingLayer() {
            drawCtx.clearRect(0, 0, drawingLayer.width, drawingLayer.height);
        }

        function toggleDrawMode() {
            isDrawMode = !isDrawMode;
            const btn = document.getElementById('toggle-draw-btn');
            const controls = document.getElementById('draw-controls');

            if (isDrawMode) {
                btn.innerText = 'Disable Drawing';
                btn.style.background = '#28a745';
                controls.style.display = 'flex';
                memeCanvas.style.cursor = 'crosshair';
            } else {
                btn.innerText = 'Enable Drawing';
                btn.style.background = '#444';
                controls.style.display = 'none';
                memeCanvas.style.cursor = 'default';
            }
        }

        function clearDrawing() {
            clearDrawingLayer();
            drawHistory = [];
            historyStep = -1;
            drawMeme();
        }

        // Click to Add Text & Drag Logic
        // canvasObjects: Array of { type: 'text'|'image', content: string, x, y, color?, size, width?, height?, imgObj? }
        let canvasObjects = [];
        let isDeepFried = false;
        let selectedObjectIndex = -1;
        let isDraggingObject = false;
        let dragStartX, dragStartY; // To store initial mouse position for dragging

        function toggleDeepFry() {
            isDeepFried = !isDeepFried;
            const btn = document.getElementById('deep-fry-btn');
            if (isDeepFried) {
                btn.style.boxShadow = "0 0 15px #ff0000";
                btn.innerText = "üî• Fried!";
            } else {
                btn.style.boxShadow = "none";
                btn.innerText = "üî• Deep Fry";
            }
            drawMeme();
        }

        function addSticker(emoji) {
            // Add emoji as text
            canvasObjects.push({
                type: 'text',
                content: emoji,
                x: memeCanvas.width / 2,
                y: memeCanvas.height / 2,
                color: '#ffffff',
                size: 100
            });
            selectedObjectIndex = canvasObjects.length - 1;
            drawMeme();
        }

        function addCustomImage(url) {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                // Default size: 100px width, maintain aspect ratio
                const scale = 100 / img.width;
                canvasObjects.push({
                    type: 'image',
                    content: url,
                    x: memeCanvas.width / 2,
                    y: memeCanvas.height / 2,
                    width: 100,
                    height: img.height * scale,
                    imgObj: img
                });
                selectedObjectIndex = canvasObjects.length - 1;
                drawMeme();
            };
            img.src = url;
        }

        function deleteSelectedObject() {
            if (selectedObjectIndex !== -1) {
                canvasObjects.splice(selectedObjectIndex, 1);
                selectedObjectIndex = -1;
                drawMeme();
            }
        }

        function getHitObjectIndex(x, y) {
            // Iterate backwards to select top-most item first
            for (let i = canvasObjects.length - 1; i >= 0; i--) {
                const obj = canvasObjects[i];
                let left, right, top, bottom;

                if (obj.type === 'text') {
                    const fontSize = Math.floor(memeCanvas.width * (obj.size / 400));
                    ctx.font = `bold ${fontSize}px Impact, sans-serif`;
                    const metrics = ctx.measureText(obj.content);
                    const width = metrics.width;
                    const height = fontSize;
                    left = obj.x - width / 2;
                    right = obj.x + width / 2;
                    top = obj.y - height / 2;
                    bottom = obj.y + height / 2;
                } else if (obj.type === 'image') {
                    left = obj.x - obj.width / 2;
                    right = obj.x + obj.width / 2;
                    top = obj.y - obj.height / 2;
                    bottom = obj.y + obj.height / 2;
                }

                const pad = 10; // Add some padding for easier clicking
                if (x >= left - pad && x <= right + pad && y >= top - pad && y <= bottom + pad) {
                    return i;
                }
            }
            return -1;
        }

        function handleCanvasInteractionStart(e) {
            if (isDrawMode) {
                startDrawing(e);
                return;
            }

            const rect = memeCanvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (memeCanvas.width / rect.width);
            const y = (e.clientY - rect.top) * (memeCanvas.height / rect.height);

            selectedObjectIndex = getHitObjectIndex(x, y);
            if (selectedObjectIndex !== -1) {
                isDraggingObject = true;
                dragStartX = x - canvasObjects[selectedObjectIndex].x;
                dragStartY = y - canvasObjects[selectedObjectIndex].y;
                memeCanvas.style.cursor = 'grabbing';
            } else {
                // If no object is selected, prompt to add new text
                const text = prompt("Enter text to add here:");
                if (text) {
                    canvasObjects.push({
                        type: 'text',
                        content: text,
                        x: x,
                        y: y,
                        color: document.getElementById('text-color').value,
                        size: document.getElementById('font-size').value
                    });
                    selectedObjectIndex = canvasObjects.length - 1;
                }
            }
            drawMeme(); // Redraw to show selection or new text
        }

        function handleCanvasInteractionMove(e) {
            if (isDrawMode) {
                draw(e);
                return;
            }

            if (isDraggingObject && selectedObjectIndex !== -1) {
                const rect = memeCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (memeCanvas.width / rect.width);
                const y = (e.clientY - rect.top) * (memeCanvas.height / rect.height);

                canvasObjects[selectedObjectIndex].x = x - dragStartX;
                canvasObjects[selectedObjectIndex].y = y - dragStartY;
                drawMeme();
            } else {
                // Change cursor if hovering over an object
                const rect = memeCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (memeCanvas.width / rect.width);
                const y = (e.clientY - rect.top) * (memeCanvas.height / rect.height);
                if (getHitObjectIndex(x, y) !== -1) {
                    memeCanvas.style.cursor = 'grab';
                } else {
                    memeCanvas.style.cursor = 'default';
                }
            }
        }

        function handleCanvasInteractionEnd() {
            if (isDrawMode) {
                stopDrawing();
                return;
            }
            isDraggingObject = false;
            memeCanvas.style.cursor = 'default';
        }

        // Event Listeners for Drawing & Clicking
        memeCanvas.addEventListener('mousedown', handleCanvasInteractionStart);
        memeCanvas.addEventListener('mousemove', handleCanvasInteractionMove);
        memeCanvas.addEventListener('mouseup', handleCanvasInteractionEnd);
        memeCanvas.addEventListener('mouseout', handleCanvasInteractionEnd);

        // Touch support
        memeCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = memeCanvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) * (memeCanvas.width / rect.width);
            const y = (touch.clientY - rect.top) * (memeCanvas.height / rect.height);

            if (isDrawMode) {
                startDrawing({ offsetX: x, offsetY: y });
            } else {
                // Simulate mousedown for object interaction
                handleCanvasInteractionStart({ clientX: touch.clientX, clientY: touch.clientY });
            }
        });
        memeCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = memeCanvas.getBoundingClientRect();
            const x = (touch.clientX - rect.left) * (memeCanvas.width / rect.width);
            const y = (touch.clientY - rect.top) * (memeCanvas.height / rect.height);

            if (isDrawMode) {
                draw({ offsetX: x, offsetY: y });
            } else {
                // Simulate mousemove for object interaction
                handleCanvasInteractionMove({ clientX: touch.clientX, clientY: touch.clientY });
            }
        });
        memeCanvas.addEventListener('touchend', handleCanvasInteractionEnd);

        function startDrawing(e) {
            if (!isDrawMode) return;
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function draw(e) {
            if (!isDrawing || !isDrawMode) return;

            drawCtx.beginPath();
            drawCtx.moveTo(lastX, lastY);
            drawCtx.lineTo(e.offsetX, e.offsetY);
            drawCtx.strokeStyle = document.getElementById('brush-color').value;
            drawCtx.lineWidth = document.getElementById('brush-size').value;
            drawCtx.lineCap = 'round';
            drawCtx.stroke();

            [lastX, lastY] = [e.offsetX, e.offsetY];
            drawMeme(); // Update main canvas
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveDrawingState(); // Save state on stroke end
            }
        }

        function drawMeme() {
            if (!currentTemplate) return;

            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = currentTemplate.url;

            img.onload = () => {
                // Sync drawing layer size if needed
                if (drawingLayer.width !== memeCanvas.width || drawingLayer.height !== memeCanvas.height) {
                    // Save current drawing
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = drawingLayer.width;
                    tempCanvas.height = drawingLayer.height;
                    tempCanvas.getContext('2d').drawImage(drawingLayer, 0, 0);

                    // Resize
                    drawingLayer.width = memeCanvas.width;
                    drawingLayer.height = memeCanvas.height;

                    // Restore drawing (scaled)
                    drawCtx.drawImage(tempCanvas, 0, 0, memeCanvas.width, memeCanvas.height);
                }

                // Apply Deep Fry Filter to Context BEFORE drawing image
                if (isDeepFried) {
                    ctx.filter = 'contrast(200%) saturate(200%) brightness(110%)';
                } else {
                    ctx.filter = 'none';
                }

                ctx.drawImage(img, 0, 0, memeCanvas.width, memeCanvas.height);

                // Reset filter for text/drawing so they stay sharp? 
                // Actually deep fry usually applies to everything. 
                // But let's keep text sharp for readability, or fry it all?
                // "Dank" memes usually have fried text too. Let's keep the filter on!
                // Wait, if I keep filter on, it applies to subsequent draws.

                // Draw the drawing layer on top of image
                ctx.drawImage(drawingLayer, 0, 0);

                const topText = document.getElementById('top-text').value.toUpperCase();
                const bottomText = document.getElementById('bottom-text').value.toUpperCase();
                const textColor = document.getElementById('text-color').value;
                const outlineColor = document.getElementById('outline-color').value;
                const fontSizeVal = document.getElementById('font-size').value;

                // Text Adjustment Values
                const topTextY = document.getElementById('top-text-y').value;
                const bottomTextY = document.getElementById('bottom-text-y').value;

                ctx.fillStyle = textColor;
                ctx.strokeStyle = outlineColor;
                ctx.lineWidth = Math.max(2, memeCanvas.width / 200); // Dynamic stroke width
                ctx.textAlign = 'center';

                // Calculate font size relative to canvas width but scaled by slider
                const fontSize = Math.floor(memeCanvas.width * (fontSizeVal / 400));
                ctx.font = `bold ${fontSize}px Impact, sans-serif`;

                // Draw Top Text
                if (topText) {
                    ctx.textBaseline = 'top';
                    const x = memeCanvas.width / 2;
                    // Use slider value as percentage of height padding
                    const y = (memeCanvas.height * (topTextY / 100));
                    ctx.fillText(topText, x, y);
                    ctx.strokeText(topText, x, y);
                }

                // Draw Bottom Text
                if (bottomText) {
                    ctx.textBaseline = 'bottom';
                    const x = memeCanvas.width / 2;
                    // Use slider value as percentage from bottom
                    const y = memeCanvas.height - (memeCanvas.height * (bottomTextY / 100));
                    ctx.fillText(bottomText, x, y);
                    ctx.strokeText(bottomText, x, y);
                }

                // Draw Custom Objects (Text & Images)
                canvasObjects.forEach((obj, index) => {
                    let width, height;

                    if (obj.type === 'text') {
                        ctx.fillStyle = obj.color;
                        ctx.strokeStyle = outlineColor;
                        const fontSize = Math.floor(memeCanvas.width * (obj.size / 400));
                        ctx.font = `bold ${fontSize}px Impact, sans-serif`;
                        ctx.textBaseline = 'middle';
                        ctx.fillText(obj.content, obj.x, obj.y);
                        ctx.strokeText(obj.content, obj.x, obj.y);

                        const metrics = ctx.measureText(obj.content);
                        width = metrics.width;
                        height = fontSize;
                    } else if (obj.type === 'image' && obj.imgObj) {
                        // Draw image centered at x,y
                        ctx.drawImage(obj.imgObj, obj.x - obj.width / 2, obj.y - obj.height / 2, obj.width, obj.height);
                        width = obj.width;
                        height = obj.height;
                    }

                    // Draw selection box if selected
                    if (index === selectedObjectIndex) {
                        ctx.strokeStyle = '#00d2ff';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(obj.x - width / 2 - 5, obj.y - height / 2 - 5, width + 10, height + 10);
                        ctx.setLineDash([]);
                    }
                });

                // Show/Hide Text Controls
                const textControls = document.getElementById('text-controls');
                if (textControls) {
                    if (selectedObjectIndex !== -1) {
                        textControls.style.display = 'flex';
                        // Update label based on type
                        const label = textControls.querySelector('span');
                        if (label) label.innerText = canvasObjects[selectedObjectIndex].type === 'text' ? 'Text Selected' : 'Sticker Selected';
                    } else {
                        textControls.style.display = 'none';
                    }
                }
            };
        }

        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);

            // Update selector value if it exists
            const themeSelect = document.getElementById('theme-selector');
            if (themeSelect) themeSelect.value = theme;
        }

        // Load saved theme immediately
        (function () {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            // We can't set the select value here because DOM might not be ready, 
            // but we'll do it in DOMContentLoaded as well.
        })();

        document.addEventListener('DOMContentLoaded', () => {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            const themeSelect = document.getElementById('theme-selector');
            if (themeSelect) themeSelect.value = savedTheme;
        });

        function downloadCreatedMeme() {
            const link = document.createElement('a');
            link.download = `meme-${Date.now()}.png`;
            link.href = memeCanvas.toDataURL();
            link.click();
        }

        async function shareCreatedMeme() {
            memeCanvas.toBlob(async (blob) => {
                const file = new File([blob], 'meme.png', { type: 'image/png' });
                if (navigator.share) {
                    try {
                        await navigator.share({
                            files: [file],
                            title: 'My Meme',
                            text: 'Check out this meme I created with MemeMaster AI! ü§ñ‚ú®'
                        });
                    } catch (e) { console.error(e); }
                } else {
                    alert('Sharing is not supported on this browser/device. Please download the image instead.');
                }
            });
        }

        function generateAIImage() {
            const prompt = document.getElementById('ai-prompt').value;
            if (!prompt) return alert('Please enter a prompt for the AI!');

            const btn = document.querySelector('button[onclick="generateAIImage()"]');
            const originalText = btn.innerText;
            btn.innerText = '‚è≥ Generating...';
            btn.disabled = true;

            // Use Pollinations.ai (Free, No API Key required)
            // Add random seed to ensure new image on same prompt
            const seed = Math.floor(Math.random() * 10000);
            const url = `https://image.pollinations.ai/prompt/${encodeURIComponent(prompt)}?seed=${seed}&width=800&height=800&nologo=true`;

            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                currentTemplate = {
                    url: url,
                    width: img.width,
                    height: img.height,
                    isCustom: true
                };

                // Reset grid selection
                const grid = document.getElementById('template-grid');
                Array.from(grid.children).forEach(c => c.querySelector('img').style.borderColor = 'transparent');

                // Resize canvas to fit
                const maxWidth = 800;
                if (img.width > maxWidth) {
                    const scale = maxWidth / img.width;
                    memeCanvas.width = maxWidth;
                    memeCanvas.height = img.height * scale;
                } else {
                    memeCanvas.width = img.width;
                    memeCanvas.height = img.height;
                }

                drawMeme();

                btn.innerText = originalText;
                btn.disabled = false;
            };
            img.onerror = () => {
                alert('Failed to generate image. Please try a different prompt.');
                btn.innerText = originalText;
                btn.disabled = false;
            };
            img.src = url;
        }
    </script>
</body>

</html>